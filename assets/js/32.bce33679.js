(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{294:function(t,s,a){"use strict";a.r(s);var r=a(13),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"四、变量、作用域和内存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、变量、作用域和内存"}},[t._v("#")]),t._v(" 四、变量、作用域和内存")]),t._v(" "),s("h3",{attrs:{id:"引用值和原始值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#引用值和原始值"}},[t._v("#")]),t._v(" 引用值和原始值")]),t._v(" "),s("p",[t._v("原始值有 undefined、symbol、null、string、number、boolean，引用值有对象 object，操作的是对对象的引用。")]),t._v(" "),s("p",[t._v("对于"),s("strong",[t._v("复制")]),t._v("来说，原始值直接将 a 的值赋值给 b，但是对于引用值来说，是将 a 所指向的"),s("strong",[t._v("引用地址")]),t._v("赋给 b，故两者有联系，改其一变二者。")]),t._v(" "),s("p",[s("strong",[t._v("函数传参是按值传参")]),t._v("，相当于复制了参数，a 作为参数传给函数，在函数内部操作参数 'a' 对外部 a 是没有影响的，但是引用值传给函数的仍是地址，故还是会影响外部 a，但是当函数内部参数不再指向该地址时，二者就没有关系了。")]),t._v(" "),s("p",[t._v("原始值没有动态属性，引用值可以随意增删查改属性值，称之为动态属性。")]),t._v(" "),s("h3",{attrs:{id:"上下文和作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#上下文和作用域"}},[t._v("#")]),t._v(" 上下文和作用域")]),t._v(" "),s("p",[t._v("函数和 window 产生上下文，其中 window 为全局上下文，函数为局部上下文。")]),t._v(" "),s("p",[t._v("上下文产生作用域链，作用域链是栈操作，越里层越早出栈，也就能访问到越外层的变量。")]),t._v(" "),s("p",[t._v("当变量在当前上下文没有找到时，沿着作用域链往外寻找，直到找到全局上下文。")]),t._v(" "),s("h3",{attrs:{id:"内存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存"}},[t._v("#")]),t._v(" 内存")]),t._v(" "),s("p",[t._v("垃圾回收（GC）\n计数回收法：产生引用时，计数加一，清除引用时，计数减一，若计数为 0，则进行垃圾回收，整个过程是不可见的，故容易有未清除引用导致浪费内存的情况")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"lyf"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 右边定义了一个对象 0x10000 而 obj 指向了该地址，即引用了它 计数为 1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" test "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// test 也指向了 obj 指向的地址，即也对对象 0x10000 进行引用了 计数加 1 为 2")]),t._v("\nobj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 计数减 1 为 1 0x1000 仍未被回收")]),t._v("\ntest "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 计数减 1 为 0 0x1000 被回收")]),t._v("\n")])])]),s("p",[t._v("内存泄漏\n对象引用一直无法达到 0, 也就一直无法回收。检查内存，可以使用终端 process.memoryUsage()，或者控制台 Memory，打印快照前要 GC")])])}),[],!1,null,null,null);s.default=e.exports}}]);