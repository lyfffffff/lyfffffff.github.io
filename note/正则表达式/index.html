<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>LYFFFF 的博客呀</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="./public/logo.webp">
    <meta name="description" content="道阻且长，勤能补拙">
    
    <link rel="preload" href="/assets/css/0.styles.9825735b.css" as="style"><link rel="preload" href="/assets/js/app.6530ad20.js" as="script"><link rel="preload" href="/assets/js/2.2defd20b.js" as="script"><link rel="preload" href="/assets/js/20.ab9731c3.js" as="script"><link rel="prefetch" href="/assets/js/10.5b87f6f1.js"><link rel="prefetch" href="/assets/js/11.605e13b4.js"><link rel="prefetch" href="/assets/js/12.edb8b435.js"><link rel="prefetch" href="/assets/js/13.42c47d09.js"><link rel="prefetch" href="/assets/js/14.acae71de.js"><link rel="prefetch" href="/assets/js/15.c19c27bf.js"><link rel="prefetch" href="/assets/js/16.28ea1cb9.js"><link rel="prefetch" href="/assets/js/17.2323a2f9.js"><link rel="prefetch" href="/assets/js/18.94c1c8f9.js"><link rel="prefetch" href="/assets/js/19.1c94f1fe.js"><link rel="prefetch" href="/assets/js/21.2cc40154.js"><link rel="prefetch" href="/assets/js/22.258a8bcb.js"><link rel="prefetch" href="/assets/js/3.934fae14.js"><link rel="prefetch" href="/assets/js/4.11957e18.js"><link rel="prefetch" href="/assets/js/5.e5b70a6f.js"><link rel="prefetch" href="/assets/js/6.4169e03e.js"><link rel="prefetch" href="/assets/js/7.c3602c94.js"><link rel="prefetch" href="/assets/js/8.f8905adf.js"><link rel="prefetch" href="/assets/js/9.8d9924b6.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9825735b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">LYFFFF 的博客呀</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Hmoe
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记" class="dropdown-title"><span class="title">笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="笔记" class="mobile-dropdown-title"><span class="title">笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/webpack/" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/note/正则表达式/" class="nav-link">
  正则表达式
</a></li><li class="dropdown-item"><!----> <a href="/note/客户端存储/" class="nav-link">
  客户端存储
</a></li><li class="dropdown-item"><!----> <a href="/note/模块化/" class="nav-link">
  模块化
</a></li><li class="dropdown-item"><!----> <a href="/note/渲染式组件/" class="nav-link">
  渲染式组件
</a></li><li class="dropdown-item"><!----> <a href="/note/原型和原型链/" class="nav-link">
  原型和原型链
</a></li><li class="dropdown-item"><!----> <a href="/note/组件传值/" class="nav-link">
  组件传值
</a></li><li class="dropdown-item"><!----> <a href="/note/Reflect/" class="nav-link">
  Reflect
</a></li><li class="dropdown-item"><!----> <a href="/note/Vue响应式原理/" class="nav-link">
  Vue响应式原理
</a></li><li class="dropdown-item"><!----> <a href="/note/VueRouter/" class="nav-link">
  VueRouter
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于" class="dropdown-title"><span class="title">关于</span> <span class="arrow down"></span></button> <button type="button" aria-label="关于" class="mobile-dropdown-title"><span class="title">关于</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/lyfffffff" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/LYFFFF_" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSND
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Hmoe
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记" class="dropdown-title"><span class="title">笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="笔记" class="mobile-dropdown-title"><span class="title">笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/webpack/" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/note/正则表达式/" class="nav-link">
  正则表达式
</a></li><li class="dropdown-item"><!----> <a href="/note/客户端存储/" class="nav-link">
  客户端存储
</a></li><li class="dropdown-item"><!----> <a href="/note/模块化/" class="nav-link">
  模块化
</a></li><li class="dropdown-item"><!----> <a href="/note/渲染式组件/" class="nav-link">
  渲染式组件
</a></li><li class="dropdown-item"><!----> <a href="/note/原型和原型链/" class="nav-link">
  原型和原型链
</a></li><li class="dropdown-item"><!----> <a href="/note/组件传值/" class="nav-link">
  组件传值
</a></li><li class="dropdown-item"><!----> <a href="/note/Reflect/" class="nav-link">
  Reflect
</a></li><li class="dropdown-item"><!----> <a href="/note/Vue响应式原理/" class="nav-link">
  Vue响应式原理
</a></li><li class="dropdown-item"><!----> <a href="/note/VueRouter/" class="nav-link">
  VueRouter
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于" class="dropdown-title"><span class="title">关于</span> <span class="arrow down"></span></button> <button type="button" aria-label="关于" class="mobile-dropdown-title"><span class="title">关于</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/lyfffffff" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/LYFFFF_" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSND
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" aria-current="page" class="active sidebar-link">正则表达式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#_1-正则表达式简介" class="sidebar-link">1. 正则表达式简介</a></li><li class="sidebar-sub-header"><a href="/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#_2-神奇的小括号" class="sidebar-link">2. 神奇的小括号</a></li><li class="sidebar-sub-header"><a href="/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#_3-正则断言" class="sidebar-link">3. 正则断言</a></li><li class="sidebar-sub-header"><a href="/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#_4-匹配的本质-回溯" class="sidebar-link">4. 匹配的本质——回溯</a></li><li class="sidebar-sub-header"><a href="/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#_5-正则练习" class="sidebar-link">5，正则练习</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>[toc]</p> <h1 id="正则表达式"><a href="#正则表达式" class="header-anchor">#</a> 正则表达式</h1> <h2 id="_1-正则表达式简介"><a href="#_1-正则表达式简介" class="header-anchor">#</a> 1. 正则表达式简介</h2> <p>正则表达式（Regular Expression）是一种文本模式，用于匹配字符串，要么<strong>匹配字符</strong>，要么<strong>匹配位置</strong>。</p> <h3 id="_1-1-什么是位置"><a href="#_1-1-什么是位置" class="header-anchor">#</a> 1.1. 什么是位置</h3> <p>位置不是字符，指的是两个相邻字符之间的空隙，可以理解为空字符 <code>&quot;&quot;</code>。</p> <p>例如字符串 <code>&quot;ab&quot;</code> 可以理解为 <code>&quot;a&quot; + &quot;&quot; + &quot;b&quot;</code>，<code>ab</code> 之间就有位置 <code>&quot;&quot;</code>。</p> <p>空字符没有数量的概念，一个空字符和 n 个空字符的意义是一样的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;&quot;</span> <span class="token operator">===</span> <span class="token string">&quot;&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;&quot;</span> <span class="token comment">// true</span>
</code></pre></div><p>又空字符可以看做是位置，所以字符之间可以有 n 个位置，例如 <code>&quot;ab&quot; = &quot;a&quot; + &quot;&quot; + &quot;&quot; + &quot;b&quot;</code>，也可看做是 <code>ab</code> 之间的位置出现了 n 次。</p> <p>反过来，多次匹配同一个位置，也可以看做是只匹配一次。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^^^[0-9]$$$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token string">&quot;1&quot;</span> <span class="token operator">===</span> <span class="token string">&quot;&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;1&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;&quot;</span> <span class="token comment">// 开头位置有三个，结尾位置有三个</span>

<span class="token comment">// 以上匹配等同于下</span>
<span class="token operator">/</span><span class="token operator">^</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span>$<span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token string">&quot;1&quot;</span> <span class="token operator">===</span> <span class="token string">&quot;&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;1&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;&quot;</span> <span class="token comment">// 开头位置有一个，结尾位置有一个</span>
</code></pre></div><h3 id="_1-2-正则实例"><a href="#_1-2-正则实例" class="header-anchor">#</a> 1.2. 正则实例</h3> <p>和数组、对象一样，可以通过调用构造函数、字面量生成正则实例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>flags<span class="token punctuation">)</span> <span class="token comment">// 构造实例</span>
<span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token operator">/</span>pattern<span class="token operator">/</span>flags <span class="token comment">// 字面量</span>
</code></pre></div><p>参数如下：</p> <ul><li>pattern<br>
模式，表示想要匹配的模式，有自己的语法和字符。</li> <li>flags<br>
可选，作为匹配模式的修饰符。
可以使用多个修饰符。</li></ul> <h4 id="_1-2-1-常见语法"><a href="#_1-2-1-常见语法" class="header-anchor">#</a> 1.2.1. 常见语法</h4> <table><thead><tr><th>语法</th> <th>常见符号</th></tr></thead> <tbody><tr><td>量词</td> <td>+、?、*、^、$、{X}、{X,}、{X,Y}</td></tr> <tr><td>修饰符</td> <td>g、i、m</td></tr> <tr><td>元字符</td> <td>.、\s、\S、\b、\B、\d、\D、\w、\W</td></tr> <tr><td>范围</td> <td>[0-9]、[A-Z]、[a-z]、[abc]、[^abc]</td></tr></tbody></table> <p>基础语法以记忆为主，不做赘述，如有遗忘，可在下面网站查询：</p> <blockquote><p><a href="https://www.runoob.com/jsref/jsref-obj-regexp.html" target="_blank" rel="noopener noreferrer">JavaScript RegExp 对象<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>正因为有自己的符号语法，正则表达式中匹配诸如 <code>+</code> 、<code>}</code> 等特殊符号，都需要使用 <code>\</code> 进行转义，例如 <code>+</code> 转为 <code>\+</code>。</p> <h3 id="_1-3-使用正则表达式"><a href="#_1-3-使用正则表达式" class="header-anchor">#</a> 1.3. 使用正则表达式</h3> <p>任意和匹配相关的方法，都可以使用正则表达式作为匹配项，例如验证、查询、切分、提取、替换，第一步都是先匹配。</p> <p>RegExp 和 String 实例的正则表达式使用场景如下：</p> <h4 id="_1-3-1-regexp-实例方法"><a href="#_1-3-1-regexp-实例方法" class="header-anchor">#</a> 1.3.1. RegExp 实例方法</h4> <ul><li><code>RegExp.prototype.exec(str):()=&gt;Array|null</code><br>
匹配，在字符串参数 str 中搜索匹配，若符合匹配返回结果数组，否则返回 null。
当正则表达式携带修饰符 g 时，可以对一个字符串多次调用 exec 方法，搜索从上次匹配的结束索引开始。
结果数组的结构如下：</li></ul> <table><thead><tr><th>结果数组属性</th> <th>作用</th></tr></thead> <tbody><tr><td>[0]</td> <td>匹配到的字符串</td></tr> <tr><td>[1], ...[n ]</td> <td>括号中的分组捕获*</td></tr> <tr><td>index</td> <td>匹配的首个字符位于字符串参数 str 的索引值</td></tr> <tr><td>input</td> <td>原始字符串参数 str</td></tr> <tr><td>groups</td> <td>存储<strong>命名捕获组</strong>信息的对象，有命名的捕获组形如 <code>(?&lt;name&gt;\d)</code>，返回 <code>{name:value}</code>，其中 <code>value</code> 表示匹配到的数值。</td></tr></tbody></table> <ul><li><code>RegExp.prototype.test(str):()=&gt;Boolean</code><br>
验证，判断字符串参数 str 是否符合正则表达式的匹配。返回 true 或 false。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d{1,3}</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span> <span class="token comment">// 匹配 1~3 个数字</span>
<span class="token keyword">let</span> bri <span class="token operator">=</span> <span class="token string">'19990724'</span>
reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>bri<span class="token punctuation">)</span> <span class="token comment">// ['199', index: 0, input: '19990724', groups: undefined]</span>
reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>bri<span class="token punctuation">)</span> <span class="token comment">// ['907', index: 3, input: '19990724', groups: undefined]</span>
reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>bri<span class="token punctuation">)</span> <span class="token comment">// ture</span>

<span class="token comment">// groups 属性的作用</span>
<span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\w)(\w)(\w)(\w)(\w)(?&lt;six&gt;\w)(\w)(\w)(\w)(\w)</span><span class="token regex-delimiter">/</span></span>
reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'abcdefghijklnm'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'abcdefghij'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'j'</span><span class="token punctuation">,</span> <span class="token literal-property property">index</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">input</span><span class="token operator">:</span> <span class="token string">'abcdefghijklnm'</span><span class="token punctuation">,</span> <span class="token literal-property property">groups</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token literal-property property">six</span><span class="token operator">:</span> <span class="token string">'f'</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
</code></pre></div><h4 id="_1-3-2-string-实例方法"><a href="#_1-3-2-string-实例方法" class="header-anchor">#</a> 1.3.2. String 实例方法</h4> <ul><li><p><code>String.prototype.search(reg):()=&gt;Boolean|-1</code><br>
查找，返回正则参数 reg 在字符串中首次匹配项的<strong>索引</strong>；若无则返回 -1。</p></li> <li><p><code>String.prototype.match(reg):()=&gt;Array|null</code><br>
匹配，根据正则参数 reg 返回匹配结果，若符合匹配返回<strong>结果数组</strong>，否则返回 null。
结果数组和 exec 返回结构一样。
当正则表达式携带修饰符 g 时，返回所有匹配组成的数组，而不是拥有 input 的结果数组。</p></li> <li><p><code>String.prototype.split(reg,limit):()=&gt;Array</code><br>
分割，正则参数 reg 用于匹配应发生拆分的点，根据这些点将字符串分割为字符串<strong>数组</strong>并返回，参数 limit 表示数组最大长度。</p></li> <li><p><code>String.prototype.replace(reg,str|fun):()=&gt;String</code><br>
替换，正则表达式 reg 所匹配到的部分，会替换为参数二。
参数二可选值为字符串和函数，若为字符串则直接替换。
若为函数时，函数返回值作为替换字符串，函数参数如下：</p></li></ul> <table><thead><tr><th>变量名</th> <th>代表的值</th> <th>match/exec 映射</th></tr></thead> <tbody><tr><td>match</td> <td>匹配的子串</td> <td>与结果数组中的 [0] 属性相同</td></tr> <tr><td>p1,p2, ...</td> <td>pn 表示第 n 个捕获组</td> <td>与结果数组中的 [1]...[n] 属性相同</td></tr> <tr><td>offset</td> <td>匹配到的子字符串在原字符串中的偏移量。例如原字符串为 <code>&quot;abcd&quot;</code>，匹配到的子字符串是 <code>&quot;bcd&quot;</code>，那么 offset 值为 1</td> <td>与 match/exec 返回结果数组中的 index 属性相同</td></tr> <tr><td>string</td> <td>被匹配的原字符串</td> <td>与结果数组中的 input 属性相同</td></tr> <tr><td>NamedCaptureGroup</td> <td>命名捕获组匹配的对象</td> <td>与结果数组中的 groups 属性相同</td></tr></tbody></table> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">-</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
<span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'1999-07-24'</span>
str<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span> <span class="token comment">// 4</span>
str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span> <span class="token comment">// ['-', '-']</span>
str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span> <span class="token comment">// ['1999', '07', '24']</span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span><span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token comment">// '1999/07/24'</span>
</code></pre></div><h4 id="_1-3-3-总结"><a href="#_1-3-3-总结" class="header-anchor">#</a> 1.3.3. 总结</h4> <p>当想要知道在一个字符串中的一个匹配是否被找到，可以使用 test 或 search 方法；</p> <p>想得到更详细的匹配信息则使用 exec 或 match 方法。</p> <p>优先选择 exec，因为在全局模式下，match 返回的结果不包含具体信息。</p> <h2 id="_2-神奇的小括号"><a href="#_2-神奇的小括号" class="header-anchor">#</a> 2. 神奇的小括号</h2> <p>在匹配中，小括号最初是用于<strong>分组</strong>和<strong>分支</strong>的，常用于给符号一个范围。</p> <p>正则中的符号都比较极端，范围概念是很薄弱的，例如 <code>+、*、?</code> 只对符号前一个字符起作用，<code>|</code> 又将整个式子分成左右两部分。</p> <ul><li><p>分组
<code>/(abc)+/</code> 和 <code>/abc+/</code> 对比，前者表示 <code>abc</code> 出现一次或多次，后者表示字符串 <code>ab</code> 后 <code>c</code> 出现一次或多次。若为 <code>/a+b+c+/</code>，更加不同。</p></li> <li><p>分支
<code>/a(b|c)/</code> 和 <code>/ab|c/</code> 对比，前者表示匹配 <code>ab</code> 或 <code>ac</code>，后者表示匹配 <code>ab</code> 或 <code>c</code>。</p></li></ul> <p>这就是小括号的分组和分支作用，但如果小括号和正则符号不搭噶，小括号还有啥用呢？例如 <code>/a(bc)/</code> 和 <code>/abc/</code>。</p> <p>括号更重要的作用，是提供了捕获组，便于我们引用它。</p> <p>引用某个捕获组，会有两种情形：在 JavaScript 里引用它，在正则表达式里引用它。</p> <h3 id="_2-1-javascript-中获取捕获组"><a href="#_2-1-javascript-中获取捕获组" class="header-anchor">#</a> 2.1. JavaScript 中获取捕获组</h3> <h4 id="结果数组"><a href="#结果数组" class="header-anchor">#</a> 结果数组</h4> <p>调用 exec 和 match ，返回的结果数组中，索引值 1~n 所在的数组项，按顺序保存了捕获组的信息。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> bri <span class="token operator">=</span> <span class="token string">'19990724'</span>
<span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\d{4})(\d{2})(\d{2})</span><span class="token regex-delimiter">/</span></span>
reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>bri<span class="token punctuation">)</span> <span class="token comment">// ['19990724', '1999', '07', '24', index: 0, input: '19990724', groups: undefined]</span>
bri<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span> <span class="token comment">// ['19990724', '1999', '07', '24', index: 0, input: '19990724', groups: undefined]</span>
</code></pre></div><h4 id="regexp-1-regexp-9"><a href="#regexp-1-regexp-9" class="header-anchor">#</a> RegExp.$1 ~ RegExp.$9</h4> <p>只要进行和正则匹配有关的操作，即调用 RegExp 和 String 实例中正则表达式相关方法（exec、test、match、replace、split、search），</p> <p>正则构造函数都会在 $1 至 $9 属性中保存此次捕获组的信息，若捕获组超过了 9 个，无法使用 RegExp.$n 获取。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span> <span class="token comment">// 10 个捕获组</span>
    <span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;123456789101112&quot;</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>regex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 能够获取 10 个捕获组</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$9<span class="token punctuation">,</span> RegExp<span class="token punctuation">.</span>$10<span class="token punctuation">)</span> <span class="token comment">// 只能获取 1-9 个捕获组</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token comment">// ['12345678910', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', index: 0, input: '123456789101112', groups: undefined]</span>
<span class="token comment">// '9' undefined</span>
</code></pre></div><h4 id="string-prototype-replace"><a href="#string-prototype-replace" class="header-anchor">#</a> String.prototype.replace</h4> <p>在字符串的 replace 方法中，可以在第二个参数中获取捕获组。</p> <p>使用 <code>$n</code> 获取正则表达式的捕获组，n 没有限制，即 <code>$11</code> 表示正则的第 11 个捕获组。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;123456789101112&quot;</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span class="token string">'$11'</span><span class="token punctuation">)</span> <span class="token comment">// '1112'</span>
</code></pre></div><h3 id="_2-2-正则表达式中获取捕获组"><a href="#_2-2-正则表达式中获取捕获组" class="header-anchor">#</a> 2.2. 正则表达式中获取捕获组</h3> <p>正则表达式可以引用自身的捕获组，但只能引用之前出现的捕获组，即反向引用。</p> <p>正则表达式中，使用 <code>\n</code> 表示引用前面的第 n 个自身捕获组，n 没有限制，即 <code>\11</code> 表示引用表达式的第 11 个捕获组。</p> <p>注意，<code>\n</code> 是具化为捕获组所捕获到的字符，而不是同样规则，例如 <code>/(\d{4})(\d{2})\2/</code>，<code>\2</code> 并不是等同于 <code>(\d{2})</code> ，而是等同于 <code>(\d{2})</code> 所匹配的字符。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> bri <span class="token operator">=</span> <span class="token string">'19990724'</span>
<span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\d{4})(\d{2})\2</span><span class="token regex-delimiter">/</span></span>
reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>bri<span class="token punctuation">)</span> <span class="token comment">// false，因为第二个捕获组捕获到的是字符 `07`，此时正则表达式等价于 /(\d{4})(\d{2})07/</span>
</code></pre></div><p>若捕获组不存在，直接将其当做匹配字符，例如 <code>\3</code>，就匹配字符串 <code>'\3'</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\d{4})(\d{2})\3</span><span class="token regex-delimiter">/</span></span>
reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'199907\3'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><h3 id="_2-3-其余补充"><a href="#_2-3-其余补充" class="header-anchor">#</a> 2.3. 其余补充</h3> <h4 id="_2-3-1-非捕获组"><a href="#_2-3-1-非捕获组" class="header-anchor">#</a> 2.3.1. 非捕获组</h4> <p>可以使用 <code>?:</code> 表示为非捕获括号，就可以只保留分组和分支的功能，形如 <code>(?:p)</code>。</p> <p>除了特意标识的 <code>?:</code> 外，正则断言也拥有括号，但也不作为捕获组，下文再提。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 纯分组</span>
<span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?:abc)+</span><span class="token regex-delimiter">/</span></span>
reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'abcab'</span><span class="token punctuation">)</span> <span class="token comment">// ['abc', index: 0, input: 'abcab', groups: undefined]</span>
<span class="token comment">// 纯分支</span>
<span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a(?:b|c)</span><span class="token regex-delimiter">/</span></span>
reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'abcab'</span><span class="token punctuation">)</span> <span class="token comment">// ['ab', index: 0, input: 'abcab', groups: undefined] </span>
</code></pre></div><h4 id="_2-3-2-括号嵌套"><a href="#_2-3-2-括号嵌套" class="header-anchor">#</a> 2.3.2. 括号嵌套</h4> <p>分组是以左括号为主的，第几个左括号，表示第几个捕获组。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">((\d{4})((\d{2})(\d{2})))</span><span class="token regex-delimiter">/</span></span>
reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'19990724'</span><span class="token punctuation">)</span> <span class="token comment">// ['19990724', '19990724', '1999', '0724', '07', '24', index: 0, input: '19990724', groups: undefined]</span>
</code></pre></div><h2 id="_3-正则断言"><a href="#_3-正则断言" class="header-anchor">#</a> 3. 正则断言</h2> <p>断言在程序中通常指的是，到指定位置时，断言当前是否符合程序的要求。</p> <p>故正则断言指的是，到指定位置时，判断当前位置是否符合匹配要求，也就是最开始提到的匹配位置。</p> <p>正则表达式中，用于匹配位置的符号有 8 个：</p> <table><thead><tr><th>符号</th> <th>描述</th></tr></thead> <tbody><tr><td><code>^</code></td> <td>表示匹配字符串<strong>开头</strong>位置</td></tr> <tr><td>$</td> <td>表示匹配字符串<strong>结尾</strong>位置</td></tr> <tr><td><code>\b</code></td> <td>表示匹配单词边界位置，即单词字符和其他字符之间的位置，即 <code>\w</code> 和 <code>\W</code> 之间</td></tr> <tr><td><code>\B</code></td> <td><code>\b</code> 取反，表示匹配非单词边界位置</td></tr> <tr><td><code>(?=p)</code></td> <td>表示 <code>p</code> 前的位置，<code>p</code> 可以是位置，可以是子模式</td></tr> <tr><td><code>(?!p)</code></td> <td><code>(?=p)</code> 取反，表示并非是 <code>p</code> 的前面的位置</td></tr> <tr><td><code>(?&lt;=p)</code></td> <td>表示 <code>p</code> 后的位置</td></tr> <tr><td><code>(?&lt;!p)</code></td> <td><code>(?&lt;=p)</code> 取反，表示并非是 <code>p</code> 的后面的位置</td></tr></tbody></table> <p>正则断言常常指的是后四个符号，因为 <code>p</code> 是自定义的，所以后四个能匹配到我们想要的特殊位置。</p> <h3 id="_3-1-p-和-p"><a href="#_3-1-p-和-p" class="header-anchor">#</a> 3.1. (?=p) 和 (?!p)</h3> <p><code>(?=p)</code> 和 <code>(?!p)</code> 称为<strong>正向先行断言</strong>和<strong>负向先行断言</strong>。其中正负向表示肯定或否定，先行指的是位置在 <code>p</code> 的前面（好拗口）。</p> <p>按我的理解是， <code>?</code> 就是位置，<code>=</code> 和 <code>!</code> 表示等于或不等于，然后得到：位置后面等于/不等于 <code>p</code>。</p> <p>反过来就变成是：是/不是 <code>p</code> 前面的位置。</p> <p>若在先行断言前面跟随符号，例如 <code>q(?=p)</code>，则表达为 <code>p</code> 前面的符号是不是 <code>q</code>。</p> <p>正则断言的一大妙用是不会影响到 <code>p</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\w)*(?=\s)</span><span class="token regex-delimiter">/</span></span> <span class="token comment">//  匹配空白符前面的单词，但是不会影响到该空白符</span>
<span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'lyffff is my name'</span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token string">'rain'</span><span class="token punctuation">)</span> <span class="token comment">// 'rain is my name'</span>
</code></pre></div><h3 id="_3-2-p-和-p"><a href="#_3-2-p-和-p" class="header-anchor">#</a> 3.2. (?&lt;=p) 和 (?&lt;!p)</h3> <p><code>(?&lt;=p)</code> 和 <code>(?&lt;!p)</code> 中文称为<strong>正向后行断言</strong>和<strong>负向后行断言</strong>，正负向意义与上相同，后行指的是位置在 <code>p</code> 的后面。</p> <p>把 <code>(?&lt;=p)</code> 想象成 <code>(=p?)</code> ，因为 <code>p?</code> 本身就有指代出现 0 或 1 次的特殊含义，所以符号 <code>?</code> 被箭头 <code>&lt;</code> 踹到了最左边。</p> <p>解析 <code>(=p?)</code> 和 <code>(!p?)</code>，<code>?</code> 就是位置，<code>=</code> 和 <code>!</code> 表示等于或不等于，然后得到：位置前面等于/不等于 <code>p</code>。</p> <p>反过来就是：是/不是 <code>p</code> 后面的位置。</p> <p>若在后行断言后面跟随符号，例如 <code>(?&lt;=p)q</code>，则表达为 <code>p</code> 后面的符号是不是 <code>q</code>。</p> <h3 id="_3-3-断言的使用场景"><a href="#_3-3-断言的使用场景" class="header-anchor">#</a> 3.3. 断言的使用场景</h3> <p>断言和字符串的 replace 方法组合，可以做到类似插入的效果。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">&quot;lyfff&quot;</span>
<span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?=f)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span><span class="token string">'$'</span><span class="token punctuation">)</span> <span class="token comment">// &quot;ly$f$f$f&quot;</span>
</code></pre></div><p>正则断言对于取出特定的字符前后、特定字符包裹的字符串，特好使。</p> <p>例如：&quot;前端仔集合：@张三 @李四 @王五&quot;，我需要取出我所艾特的人名，即特定字符 <code>@</code> 后的子串。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">&quot;前端仔集合：@张三 @李四 @王五&quot;</span>
str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">@(\S+)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">)</span> <span class="token comment">// ['@张三', '@李四', '@王五'] 此时特殊字符也还在</span>
str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">@(\S+)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token operator">=&gt;</span>item<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// ['张三', '李四', '王五']</span>
</code></pre></div><p>换成正则断言后：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">&quot;前端仔集合：@张三 @李四 @王五&quot;</span>
str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;=@)(\S+)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">)</span> <span class="token comment">// ['张三', '李四', '王五']</span>
</code></pre></div><p>例如：&quot;[1,2,3][4,5][6][7,8]&quot;，取出所有数组字符串，即特定字符 <code>[</code>、<code>]</code>，及他们包裹的内容。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">&quot;[1,2,3][4,5][6][7,8]&quot;</span>
str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;=\[)(.)*?(?=\])</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">)</span> <span class="token comment">// ['[1,2,3]','[4,5]','[6]','[7,8]']</span>
</code></pre></div><h2 id="_4-匹配的本质-回溯"><a href="#_4-匹配的本质-回溯" class="header-anchor">#</a> 4. 匹配的本质——回溯</h2> <blockquote><p>回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、 不断“回溯”寻找解的方法，就称作“回溯法”。   ————百科百科</p></blockquote> <p>正则表达式是按顺序匹配的，且是贪心的，即满足当前量词的上限，例如 <code>/b{1,3}c/</code>，正则希望先匹配满三个 <code>b</code>，再往下匹配 <code>c</code>。</p> <p>一旦匹配失败，正则表达式就会进行回溯，回溯并不是回到上一步，而是回到<strong>可产生分支</strong>的某一步，若沿着路径回溯没有找到可产生分支的节点，则回到表达式起点，移动字符串索引。</p> <p>例如 <code>/123/</code> 匹配字符串 <code>12b123</code>，当表达式进行到 <code>3</code> 时，匹配到 <code>b</code> 字符，匹配失败；此时上一步 <code>2</code> 只能匹配字符 <code>2</code>，从这出发等同于原来的路径，故跳过，上上步 <code>1</code> 也只能匹配字符 <code>1</code>，往后走也是原来的路径，最终匹配回到起点，只能移动字符串索引。</p> <table><thead><tr><th>正则位置</th> <th>字符串位置</th> <th>结果</th></tr></thead> <tbody><tr><td>1</td> <td>&quot;12b123&quot;</td> <td>可能匹配，index 为 0</td></tr> <tr><td>12</td> <td>&quot;2b123&quot;</td> <td>可能匹配，index 为 0</td></tr> <tr><td>123</td> <td>&quot;b123&quot;</td> <td>不匹配，回溯</td></tr> <tr><td>1</td> <td>&quot;2b123&quot;</td> <td>不匹配，移动字符串索引</td></tr> <tr><td>1</td> <td>&quot;b123&quot;</td> <td>不匹配，移动字符串索引</td></tr> <tr><td>1</td> <td>&quot;123&quot;</td> <td>可能匹配，index 为 3</td></tr> <tr><td>12</td> <td>&quot;23&quot;</td> <td>可能匹配，index 为 3</td></tr> <tr><td>123</td> <td>&quot;3&quot;</td> <td>匹配成功，index 为 3</td></tr></tbody></table> <p><strong>个人理解</strong>
表达式相当于给个高度，字符串相当于一棵树，判断树够不够高。</p> <p>第一反应是沿着树干测量，不够高即匹配失败就发送回溯，找到离树干顶端最近的分叉，因为觉得它的基础好，加上分叉的长度更高的可能性大，结果不行就再往下回溯，直到回到树木的根。</p> <h3 id="_4-1-可选限定符"><a href="#_4-1-可选限定符" class="header-anchor">#</a> 4.1. 可选限定符</h3> <p>回溯法停留的位置，能够实现<strong>可选限定符</strong>，否则直接跳过。</p> <p>可选限定字符指的是在字符串不同情况下，此子表达式选择的字符会变化。</p> <p>可选限定字符中的变化，讨论的不是字符内容，指的是字符范围变化。</p> <p>因为需要进行回溯时，不管前面内容如何，是绝对符合匹配的。例如 <code>/\d\w/</code>，若匹配来到了 <code>\w</code> ，不管内容怎么变化，证明前一个字符绝对是数字。</p> <p>有范围的字符有 <code>*</code>、<code>+</code>、<code>?</code>、<code>{m,n}</code>、<code>{m,}</code>，遇到这些字符时，可能会发送回溯。</p> <p>回溯是不可见的，但是若在匹配中多次执行回溯操作，是很损耗性能的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(a+)+$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'aaaaa!'</span><span class="token punctuation">)</span>
</code></pre></div><p>我们明眼能看出来，字符串不是以 <code>a</code> 字符结尾，匹配注定失败返回 null，但其真实的匹配流程如下：</p> <table><thead><tr><th>步骤</th> <th>正则位置</th> <th>字符串位置</th> <th>结果</th></tr></thead> <tbody><tr><td>1</td> <td>^</td> <td>'aaaaa!'</td> <td>可能匹配</td></tr> <tr><td>2</td> <td>^a</td> <td>'aaaaa!'</td> <td>可能匹配</td></tr> <tr><td>3</td> <td>^(a+)</td> <td>'!'</td> <td>可能匹配</td></tr> <tr><td>4</td> <td>^(a+)+</td> <td>'!'</td> <td>可能匹配</td></tr> <tr><td>5</td> <td>^(a+)+$</td> <td>'!'</td> <td>匹配失败</td></tr> <tr><td>6</td> <td>^(a+)</td> <td>'a!'</td> <td>可能匹配</td></tr> <tr><td>7</td> <td>^(a+)+</td> <td>'a!'</td> <td>可能匹配</td></tr> <tr><td>8</td> <td>^(a+)+$</td> <td>'a!'</td> <td>匹配失败</td></tr> <tr><td>9</td> <td>^(a+)</td> <td>'aa!'</td> <td>可能匹配</td></tr> <tr><td>10</td> <td>^(a+)+</td> <td>'aa!'</td> <td>可能匹配</td></tr> <tr><td>11</td> <td>^(a+)+$</td> <td>'aa!'</td> <td>匹配失败</td></tr> <tr><td>12</td> <td>^(a+)</td> <td>'aaa!'</td> <td>可能匹配</td></tr> <tr><td>13</td> <td>^(a+)+</td> <td>'a!'</td> <td>可能匹配</td></tr> <tr><td>14</td> <td>^(a+)+$</td> <td>'a!'</td> <td>匹配失败</td></tr> <tr><td>15</td> <td>^(a+)+</td> <td>'aaa!'</td> <td>可能匹配</td></tr> <tr><td>16</td> <td>^(a+)+$</td> <td>'aaa!'</td> <td>匹配失败</td></tr> <tr><td>17</td> <td>^(a+)</td> <td>'aaaa!'</td> <td>可能匹配</td></tr> <tr><td>18</td> <td>^(a+)+</td> <td>'!'</td> <td>可能匹配</td></tr> <tr><td>19</td> <td>^(a+)+$</td> <td>'!'</td> <td>匹配失败</td></tr> <tr><td>20</td> <td>^(a+)+</td> <td>'a!'</td> <td>可能匹配</td></tr> <tr><td>21</td> <td>^(a+)+$</td> <td>'a!'</td> <td>匹配失败</td></tr> <tr><td>22</td> <td>^(a+)+</td> <td>'aa!'</td> <td>可能匹配</td></tr> <tr><td>23</td> <td>^(a+)+$</td> <td>'aa!'</td> <td>匹配失败</td></tr> <tr><td>24</td> <td>^(a+)+</td> <td>'aaa!'</td> <td>可能匹配</td></tr> <tr><td>25</td> <td>^(a+)+$</td> <td>'aaa!'</td> <td>匹配失败</td></tr> <tr><td>26</td> <td>^(a+)+</td> <td>'aaaa!'</td> <td>可能匹配</td></tr> <tr><td>27</td> <td>^(a+)+$</td> <td>'aaaa!'</td> <td>匹配失败</td></tr></tbody></table> <p>短短的一个正则表达式，却要一直回溯到 <code>(a+)</code>，不断减少此表达式获得的字符 <code>a</code> 。</p> <h3 id="_4-2-惰性和贪婪"><a href="#_4-2-惰性和贪婪" class="header-anchor">#</a> 4.2. 惰性和贪婪</h3> <p>能够实现可选限定字符的量词分为两类，贪婪量词和惰性量词。</p> <p>多数量词是贪婪的，也就是尽可能多的匹配，能选多少就选多少。例如 <code>b{1,3}</code>，正则希望匹配三个 <code>b</code>，若没有，两个也行，若还是没有，一个不能再少了！</p> <p>但是 <code>?</code> 是个例外，它表示只匹配 0 或 1 次。</p> <p>可以在贪婪量词后加上 <code>?</code> 字符，变贪婪为惰性，也就是先取下限。</p> <p>例如 <code>*</code> 和 <code>*?</code>，前者表示匹配 0 至无数次，后者表示先匹配 0 次。</p> <p>例如 <code>+</code> 和 <code>+?</code>，前者表示匹配 1 至无数次，后者表示先匹配 1 次。</p> <p>例如 <code>{1,3}</code> 和 <code>{1,3}?</code>，前者表示匹配 1 至 3 次，后者表示先匹配 1 次。</p> <p>以 <code>+</code> 符号为例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d+</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'123456'</span>
str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span> <span class="token comment">// ['123456', index: 0, input: '123456', groups: undefined]</span>

<span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d+?</span><span class="token regex-delimiter">/</span></span>
str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span> <span class="token comment">// ['1', index: 0, input: '123456', groups: undefined]</span>
</code></pre></div><p>贪婪变惰性并不是严格的，因为始终它是可选限定字符，当匹配失败时，回溯的优先级高于惰性：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">&quot;12345&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\d{1,3})?(\d{1,3})$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span> 
</code></pre></div><p>若按照顺序，则 <code>$1</code> 为 <code>'1'</code>，<code>$2</code> 为 <code>'234'</code>，但此时要求结尾位置前匹配三个数字，匹配失败，回溯至 <code>$1</code>，发现其好像最多可以获取三个字符，使其多获取一个字符，变为 <code>'12'</code>，<code>$2</code> 为 <code>'345'</code>，符合。</p> <table><thead><tr><th>正则位置</th> <th>字符串位置</th> <th>结果</th></tr></thead> <tbody><tr><td>(\d{1,3})?</td> <td>'12345'</td> <td>可能匹配</td></tr> <tr><td>(\d{1,3})?(\d{1,3})</td> <td>'2345'</td> <td>可能匹配</td></tr> <tr><td>(\d{1,3})?(\d{1,3})$</td> <td>'5'</td> <td>匹配失败，回溯</td></tr> <tr><td>(\d{1,3})?</td> <td>'12345'</td> <td>可能匹配</td></tr> <tr><td>(\d{1,3})?(\d{1,3})</td> <td>'345'</td> <td>可能匹配</td></tr> <tr><td>(\d{1,3})?(\d{1,3})$</td> <td>''</td> <td>匹配成功</td></tr></tbody></table> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">&quot;12345&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\(d{1,3})?(\d{1,3})$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span> 
str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span> <span class="token comment">// [&quot;1234&quot;, &quot;1&quot;, &quot;234&quot;, index: 0, input: &quot;12345&quot;]</span>
</code></pre></div><h2 id="_5-正则练习"><a href="#_5-正则练习" class="header-anchor">#</a> 5，正则练习</h2> <p>1，将数字转为科学计数法
给定字符串 str = &quot;1000000000&quot;，⽤科学计数法表⽰该式，效果为：1,000,000,000
正则：断言用作插入</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> str <span class="token operator">=</span><span class="token string">&quot;1000000000&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> reg <span class="token operator">=</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?!^)(?=(\d{3})+$)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span>
</code></pre></div><hr> <p>2，将字符串转为驼峰形式
给定字符串 str = &quot;get-element-by-id&quot;，将其转化成驼峰形式，效果为：&quot;getElementById&quot;。
正则：replace 的函数替换</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">&quot;get-element-by-id&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">-(.)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span> <span class="token comment">// 匹配 '-' 及之后的⼀个字符</span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">mat<span class="token punctuation">,</span>p1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> p1<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><hr> <p>3，字符串去重
给定字符串 str = &quot;aaaaaabbbbbbbccccccc&quot;，去掉其重复字符，效果为：&quot;abc&quot;
正则：捕获组</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">&quot;aaaaaabbbbbbbccccccc&quot;</span>
<span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\w)\1*(\w)\2*(\w)\3*</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span><span class="token string">&quot;$1$2$3&quot;</span><span class="token punctuation">)</span> 
</code></pre></div><p>4，包含和排除
判断字符串是否包含 'abc' 且不包含 '//'。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> str1 <span class="token operator">=</span> <span class="token string">'abc //'</span>
<span class="token keyword">let</span> str2 <span class="token operator">=</span> <span class="token string">'abc nice'</span>
<span class="token keyword">let</span> str3 <span class="token operator">=</span> <span class="token string">'// abc'</span>
<span class="token keyword">let</span> str4 <span class="token operator">=</span> <span class="token string">'nice // abc'</span>
<span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^((?!\/\/).)*abc((?!\/\/).)*$</span><span class="token regex-delimiter">/</span></span>
</code></pre></div><p>5，正斜杠或反斜杠</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\\/]</span><span class="token regex-delimiter">/</span></span> <span class="token comment">// 可以匹配 `/` `\\` `\/`</span>
<span class="token keyword">let</span> reg_1 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\[\/]</span><span class="token regex-delimiter">/</span></span> <span class="token comment">// 匹配 `[/]`</span>
<span class="token keyword">let</span> reg_2 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\/\\]</span><span class="token regex-delimiter">/</span></span> <span class="token comment">// 可以匹配 `/` `\\` `/\\`</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.6530ad20.js" defer></script><script src="/assets/js/2.2defd20b.js" defer></script><script src="/assets/js/20.ab9731c3.js" defer></script>
  </body>
</html>
