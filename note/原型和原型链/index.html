<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>LYFFFF 的博客呀</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="./public/logo.webp">
    <meta name="description" content="道阻且长，勤能补拙">
    
    <link rel="preload" href="/assets/css/0.styles.9825735b.css" as="style"><link rel="preload" href="/assets/js/app.6530ad20.js" as="script"><link rel="preload" href="/assets/js/2.2defd20b.js" as="script"><link rel="preload" href="/assets/js/17.2323a2f9.js" as="script"><link rel="prefetch" href="/assets/js/10.5b87f6f1.js"><link rel="prefetch" href="/assets/js/11.605e13b4.js"><link rel="prefetch" href="/assets/js/12.edb8b435.js"><link rel="prefetch" href="/assets/js/13.42c47d09.js"><link rel="prefetch" href="/assets/js/14.acae71de.js"><link rel="prefetch" href="/assets/js/15.c19c27bf.js"><link rel="prefetch" href="/assets/js/16.28ea1cb9.js"><link rel="prefetch" href="/assets/js/18.94c1c8f9.js"><link rel="prefetch" href="/assets/js/19.1c94f1fe.js"><link rel="prefetch" href="/assets/js/20.ab9731c3.js"><link rel="prefetch" href="/assets/js/21.2cc40154.js"><link rel="prefetch" href="/assets/js/22.258a8bcb.js"><link rel="prefetch" href="/assets/js/3.934fae14.js"><link rel="prefetch" href="/assets/js/4.11957e18.js"><link rel="prefetch" href="/assets/js/5.e5b70a6f.js"><link rel="prefetch" href="/assets/js/6.4169e03e.js"><link rel="prefetch" href="/assets/js/7.c3602c94.js"><link rel="prefetch" href="/assets/js/8.f8905adf.js"><link rel="prefetch" href="/assets/js/9.8d9924b6.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9825735b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">LYFFFF 的博客呀</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Hmoe
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记" class="dropdown-title"><span class="title">笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="笔记" class="mobile-dropdown-title"><span class="title">笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/webpack/" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/note/正则表达式/" class="nav-link">
  正则表达式
</a></li><li class="dropdown-item"><!----> <a href="/note/客户端存储/" class="nav-link">
  客户端存储
</a></li><li class="dropdown-item"><!----> <a href="/note/模块化/" class="nav-link">
  模块化
</a></li><li class="dropdown-item"><!----> <a href="/note/渲染式组件/" class="nav-link">
  渲染式组件
</a></li><li class="dropdown-item"><!----> <a href="/note/原型和原型链/" class="nav-link">
  原型和原型链
</a></li><li class="dropdown-item"><!----> <a href="/note/组件传值/" class="nav-link">
  组件传值
</a></li><li class="dropdown-item"><!----> <a href="/note/Reflect/" class="nav-link">
  Reflect
</a></li><li class="dropdown-item"><!----> <a href="/note/Vue响应式原理/" class="nav-link">
  Vue响应式原理
</a></li><li class="dropdown-item"><!----> <a href="/note/VueRouter/" class="nav-link">
  VueRouter
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于" class="dropdown-title"><span class="title">关于</span> <span class="arrow down"></span></button> <button type="button" aria-label="关于" class="mobile-dropdown-title"><span class="title">关于</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/lyfffffff" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/LYFFFF_" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSND
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Hmoe
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记" class="dropdown-title"><span class="title">笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="笔记" class="mobile-dropdown-title"><span class="title">笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/webpack/" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/note/正则表达式/" class="nav-link">
  正则表达式
</a></li><li class="dropdown-item"><!----> <a href="/note/客户端存储/" class="nav-link">
  客户端存储
</a></li><li class="dropdown-item"><!----> <a href="/note/模块化/" class="nav-link">
  模块化
</a></li><li class="dropdown-item"><!----> <a href="/note/渲染式组件/" class="nav-link">
  渲染式组件
</a></li><li class="dropdown-item"><!----> <a href="/note/原型和原型链/" class="nav-link">
  原型和原型链
</a></li><li class="dropdown-item"><!----> <a href="/note/组件传值/" class="nav-link">
  组件传值
</a></li><li class="dropdown-item"><!----> <a href="/note/Reflect/" class="nav-link">
  Reflect
</a></li><li class="dropdown-item"><!----> <a href="/note/Vue响应式原理/" class="nav-link">
  Vue响应式原理
</a></li><li class="dropdown-item"><!----> <a href="/note/VueRouter/" class="nav-link">
  VueRouter
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于" class="dropdown-title"><span class="title">关于</span> <span class="arrow down"></span></button> <button type="button" aria-label="关于" class="mobile-dropdown-title"><span class="title">关于</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/lyfffffff" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/LYFFFF_" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSND
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/note/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/" aria-current="page" class="active sidebar-link">原型和原型链</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/#_1-前言" class="sidebar-link">1，前言</a></li><li class="sidebar-sub-header"><a href="/note/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/#_2-原型对象" class="sidebar-link">2，原型对象</a></li><li class="sidebar-sub-header"><a href="/note/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/#_3-对象原型属性" class="sidebar-link">3，对象原型属性</a></li><li class="sidebar-sub-header"><a href="/note/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/#_4-对象原型属性和函数原型对象" class="sidebar-link">4，对象原型属性和函数原型对象</a></li><li class="sidebar-sub-header"><a href="/note/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/#_5-继承" class="sidebar-link">5，继承</a></li><li class="sidebar-sub-header"><a href="/note/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/#_6-类" class="sidebar-link">6，类</a></li><li class="sidebar-sub-header"><a href="/note/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/#_7-附录" class="sidebar-link">7，附录</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>[toc]</p> <h1 id="原型和原型链"><a href="#原型和原型链" class="header-anchor">#</a> 原型和原型链</h1> <h2 id="_1-前言"><a href="#_1-前言" class="header-anchor">#</a> 1，前言</h2> <p>JS 是面向对象编程的，即无论遇到什么问题，都将实际问题转化为对象，封装对象里面的属性和方法。</p> <p>实物之间存在联系、共性和从属，那转化成的对象之间也有联系、共性和从属。</p> <p>若创建类似的对象，则会写很多重复代码。</p> <p>在 Java 等语言中，通过<strong>类</strong>构造的同一类对象，有相同的属性，并称为类实例。</p> <p>在 ES6 以前，JS 没有类的概念，是通过调用函数生成实例的。</p> <h3 id="_1-1-工厂函数"><a href="#_1-1-工厂函数" class="header-anchor">#</a> 1.1，工厂函数</h3> <p>工厂函数在内部新建一个对象，进行系列操作后，在末尾返回。</p> <p>因为函数内部执行的操作是一致的，故每次调用返回的对象一般会拥有相同的结构，根据传入的参数不同，返回属性值不同的对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token parameter">name，age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    obj<span class="token punctuation">.</span>name <span class="token operator">=</span> name
    obj<span class="token punctuation">.</span>age <span class="token operator">=</span> age
    <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token string">'lyf'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span> <span class="token comment">// {name:'lyf', age:18}</span>
<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token string">'zzz'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// {name:'zzz', age:10}</span>
</code></pre></div><p>工厂函数的一大缺点是，所生成的对象看不出来其类型，即并不知道其出自哪个工厂。</p> <p>无法识别父类，也就无法识别兄弟，同一个工厂函数返回的实例，虽然长的差不多，但没有本质的联系。</p> <h3 id="_1-2-构造函数"><a href="#_1-2-构造函数" class="header-anchor">#</a> 1.2，构造函数</h3> <p>专门用于生成实例对象的函数称为构造函数，和工厂函数的本质区别是能够像 Array、Function 一样找到自己的类型。</p> <p>工厂函数和构造函数的结构区别：</p> <p>构造函数不需要创建新的 obj，赋值操作使用 this 关键词；</p> <p>构造函数不需要 return 一个对象；</p> <p>构造函数使用 new 关键词实例化对象。</p> <p>将工厂函数改造成构造函数，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">CreateObj</span><span class="token punctuation">(</span><span class="token parameter">name，age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
 <span class="token comment">// 1，不需要新的 obj</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token comment">// 2,this赋值</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
  <span class="token comment">// 3,不需要return</span>
<span class="token punctuation">}</span>

<span class="token comment">// 4,new 构造</span>
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateObj</span><span class="token punctuation">(</span><span class="token string">'lyf'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span> <span class="token comment">// {name:'lyf', age:18}</span>
<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateObj</span><span class="token punctuation">(</span><span class="token string">'zzzz'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// {name:'zzzz', age:10}</span>
</code></pre></div><p>此时需注意，若在构造函数最后 return 了返回值，则调用结果为该 return 值。</p> <h4 id="_1-2-1-new-关键字的本质"><a href="#_1-2-1-new-关键字的本质" class="header-anchor">#</a> 1.2.1，new 关键字的本质</h4> <p>new 的本质是一个函数，这个函数将构造函数当做参数传入，生成实例对象并返回。</p> <p>new 函数的执行步骤如下：</p> <ul><li>创建新对象</li> <li>新对象的原型（<code>__proto__</code>）指向构造函数的原型对象（prototype）</li> <li>构造函数的 this 指向新对象</li> <li>执行构造函数代码，并获取返回值</li> <li>若构造函数返回值为空，返回新对象，否则返回构造函数返回值</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">newFun</span><span class="token punctuation">(</span><span class="token parameter">createFun</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> createFun<span class="token punctuation">.</span>prototype
    <span class="token keyword">let</span> trueReturn <span class="token operator">=</span> <span class="token function">createFun</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj，<span class="token operator">...</span>arguments<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> trueReturn <span class="token operator">?</span> trueReturn <span class="token operator">:</span> obj
<span class="token punctuation">}</span>

<span class="token function">newFun</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>
</code></pre></div><p>到此，才引出对象原型 （<code>__proto__</code>） 和函数的原型对象（prototype）来。</p> <h5 id="补充"><a href="#补充" class="header-anchor">#</a> 补充</h5> <p>Function.prototype.call(obj,……arg)</p> <p>本质是调用函数，全局函数中 this 指向 window， call 会让函数的 this 指向 obj，arg 表示传入函数的参数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span> <span class="token operator">==</span> obj
<span class="token keyword">this</span><span class="token punctuation">.</span>xxx <span class="token operator">==</span> obj<span class="token punctuation">.</span>xxx
</code></pre></div><h2 id="_2-原型对象"><a href="#_2-原型对象" class="header-anchor">#</a> 2，原型对象</h2> <p>每一个函数都有一个 prototype 属性，此属性指向一个对象，称为原型对象。</p> <p>原型对象有个 constructor 属性，指回函数。</p> <div class="language- extra-class"><pre class="language-text"><code>graph LR
Function--&gt;|.prototype|ProtoObj
ProtoObj--&gt;|.constructor|Function
</code></pre></div><p>此时 new 将==实例对象的原型属性==指向了==构造函数的原型对象==。</p> <p>故实例对象、构造函数、原型对象的关系如下：</p> <div class="language- extra-class"><pre class="language-text"><code>graph LR
Function--&gt;|new|obj
obj--&gt;|.__proto__|ProtoObj
Function--&gt;|.prototype|ProtoObj
ProtoObj--&gt;|.constructor|Function
</code></pre></div><h3 id="_2-1-constructor-和-prototype"><a href="#_2-1-constructor-和-prototype" class="header-anchor">#</a> 2.1，constructor 和 prototype</h3> <p>若修改函数的 prototype 对象，会修改 constructor 指向。</p> <p>同理，也会影响实例寻找类型，后面详细讨论。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Test</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token class-name">Test</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Test<span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><h2 id="_3-对象原型属性"><a href="#_3-对象原型属性" class="header-anchor">#</a> 3，对象原型属性</h2> <p>每一个对象都有一个原型属性 <code>__proto__</code>，重要作用是用于查询属性。</p> <p>当获取对象 obj_0 的属性时，先在自身寻找，若没找到则在原型属性上寻找；</p> <p>又因为对象的原型属性 obj_1 仍是对象，故也有其自身的原型属性；</p> <p>若原型属性对象 obj_1 没找到，其也会在自己的原型属性 obj_2 上寻找；</p> <p>获取属性就是<strong>自身没找到就推给原型属性</strong>的过程，相当于我打不过你我就喊我爸，我爸还打不过你他就喊他爸……</p> <p>直至某个原型属性为 null 才停止，相当于我爷爷想找他爸时发现他爸已经去天堂了，只能认命了，返回 undefined。</p> <p>一直沿着 <code>__proto__</code> 寻找，由此生成一条<strong>原型链</strong>。</p> <ul><li><code>obj.__proto__.__proto__.__proto__.__proto__</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>graph LR
obj_0--&gt;|.__proto__|obj_1
obj_1--&gt;|.__proto__|obj_2
obj_2--&gt;|.__proto__|obj_3
obj_3--&gt;|.__proto__|null
</code></pre></div><p>因为对象可以获取原型链的东西，也将此称为原型链继承，许多继承都是通过操作对象的原型属性实现的。</p> <h3 id="_3-1-对象原型属性的特点"><a href="#_3-1-对象原型属性的特点" class="header-anchor">#</a> 3.1，对象原型属性的特点</h3> <p>只能为一个对象，当将 obj 的原型属性赋值为非对象时，不起作用。</p> <p>可以将对象的原型属性赋值为 null，但是赋值过 null 的原型属性，不再有查询属性的功能。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token keyword">null</span>
obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">a</span> <span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
obj<span class="token punctuation">.</span>a <span class="token comment">// undefined</span>
</code></pre></div><p>在控制台中，对象原型属性为 <code>[[Prototype]]</code></p> <h3 id="_3-2-区分自身属性和原型属性"><a href="#_3-2-区分自身属性和原型属性" class="header-anchor">#</a> 3.2，区分自身属性和原型属性</h3> <p>对于一个对象 obj，有时候是无法判断一个属性是原型还是自身定义的，例如 for-in 遍历/ in 字符检验，自身和原型的属性都会执行。</p> <ul><li><p>Object.prototype.hasOwnProperty(str):Boolean<br>
传入一个参数，根据参数是不是实例自身属性返回一个 boolean 值。</p></li> <li><p>Object.keys(obj)<br>
返回参数 obj<strong>自身</strong>可枚举属性。</p></li></ul> <h2 id="_4-对象原型属性和函数原型对象"><a href="#_4-对象原型属性和函数原型对象" class="header-anchor">#</a> 4，对象原型属性和函数原型对象</h2> <p>因为在 new 中将对象原型属性 <code>__proto__</code> 赋值为构造函数的原型对象 prototype。</p> <p>于是实例对象原型属性和函数原型对象有了联系————对象原型属性指向构造其的构造函数的原型对象。</p> <p>但是 <code>__proto__</code> 指向其实是可以修改的，故上面那句话不绝对。</p> <p>在原生的情况下，所有实例的原型属性皆指向构造函数的原型对象 prototype。</p> <p>又有对象可以沿着原型链查找属性，对象原型属性指向构造函数原型对象。</p> <p>故原型对象最主要的作用是，用来存放==实例对象==的公有属性和公有方法。</p> <p>且 prototype 修改，对象原型属性修改，属性值修改。</p> <div class="language- extra-class"><pre class="language-text"><code>graph LR
Function--&gt;|new|obj_0
Function--&gt;|new|obj_1
Function--&gt;|new|obj_2
Function--&gt;|.prototype|ProtoObj
obj_0--&gt;|.__proto__|ProtoObj
obj_1--&gt;|.__proto__|ProtoObj
obj_2--&gt;|.__proto__|ProtoObj
</code></pre></div><h3 id="_4-1-实例与构造函数"><a href="#_4-1-实例与构造函数" class="header-anchor">#</a> 4.1，实例与构造函数</h3> <p>前面提到，工厂函数生成的实例无法识别其类型。</p> <p>构造函数可以利用原型对象和实例原型属性识别，若相等则是该类型。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">testClass</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span>fun</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> fun<span class="token punctuation">.</span>prototype
<span class="token punctuation">}</span>
</code></pre></div><h4 id="instanceof-检验类型"><a href="#instanceof-检验类型" class="header-anchor">#</a> instanceof 检验类型</h4> <p>此方法就使用到函数原型对象和实例原型属性。</p> <p>只要函数原型对象出现在实例原型链中，就认为实例是该类型的产物。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token keyword">instanceof</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span>fun</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> fun<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                obj <span class="token operator">=</span> obj<span class="token punctuation">.</span>__proto__
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="constructor-检验"><a href="#constructor-检验" class="header-anchor">#</a> constructor 检验</h4> <p>因为函数的原型对象的 constructor 属性指向函数本身。</p> <p>故实例的原型属性对象的 constructor 属性指向构造其的构造函数。</p> <p>又因为会沿着原型链寻找，故实例的 constructor 属性指向构造其的构造函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">fun</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
fun<span class="token punctuation">.</span>prototype <span class="token operator">==</span> obj<span class="token punctuation">.</span>__proto__
obj<span class="token punctuation">.</span><span class="token class-name">__proto__</span><span class="token punctuation">.</span>constructor <span class="token operator">==</span> fun <span class="token comment">// true</span>
obj<span class="token punctuation">.</span>constructor <span class="token operator">==</span> obj<span class="token punctuation">.</span><span class="token class-name">__proto__</span><span class="token punctuation">.</span>constructor <span class="token operator">==</span> fun <span class="token comment">// true</span>
</code></pre></div><p>前面提到了，可修改构造函数的 prototype 指向，故此方法也不绝对成立啦。</p> <h3 id="_4-2-object-对象上操作原型对象的方法"><a href="#_4-2-object-对象上操作原型对象的方法" class="header-anchor">#</a> 4.2，Object 对象上操作原型对象的方法</h3> <ul><li><p>Object.prototype.isPrototypeOf(obj):Boolean<br>
判断是实例是否是参数 obj 的原型属性，是返回true，否则返回 false。</p></li> <li><p>Object.getPrototypeOf(obj):Object<br>
返回传入参数 obj 的原型属性，一般为构造其的构造函数的 prototype。</p></li> <li><p>Object.setPrototypeOf(obj, prototype)<br>
参数 obj 表示实例，参数 prototype 是一个对象，表示将参数 prototype 设置为参数 obj 的原型对象。</p></li> <li><p>Object.create(obj)<br>
返回一个新对象，且该对象的原型属性指向 obj。</p></li></ul> <h4 id="_4-2-1-新的-instanceof"><a href="#_4-2-1-新的-instanceof" class="header-anchor">#</a> 4.2.1，新的 instanceof</h4> <p>使用以上放法改写 instanceof 函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Instanceof</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">L</span>，<span class="token constant">R</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 当检测对象是基本类型时，返回 false</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token constant">L</span> <span class="token operator">!=</span> <span class="token string">'Object'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> <span class="token constant">L</span> <span class="token operator">!=</span> <span class="token string">'Function'</span><span class="token punctuation">)</span><span class="token operator">||</span> <span class="token constant">L</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 类型为基本类型时，抛出错误</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token constant">R</span> <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> <span class="token constant">R</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token constant">R</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Right-hand side of instanceof is not an object&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 找到检测对象 L 指向的原型对象，判断是否与 R 相等，相等则返回 true， 不相等则往原型链后面找，直到找到 null 仍不相等，返回 false</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getProtopeOf</span><span class="token punctuation">(</span><span class="token constant">L</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getProtopeOf</span><span class="token punctuation">(</span><span class="token constant">L</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">R</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
        <span class="token constant">L</span> <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token constant">L</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_5-继承"><a href="#_5-继承" class="header-anchor">#</a> 5，继承</h2> <p>理清原型和原型链，接下来就是利用其实现继承。</p> <p>继承的表现为，函数 B 继承了函数 A，则由 B 构造出来的实例 b，也有 A 上的属性。</p> <p>其中 A 的属性包括，其构造函数的属性，和其构造函数原型对象上的属性。</p> <p>故继承必须分成两步，一步继承父类内部属性，一步继承父类原型对象的属性。</p> <h3 id="_5-1-原型链继承"><a href="#_5-1-原型链继承" class="header-anchor">#</a> 5.1，原型链继承</h3> <p>若 b 需获取 A.Prototype，即父类原型对象的属性，只能通过原型链建立，但是 <code>b.__proto__</code> 需指向 B.prototype，故至少得是 <code>b.__proto__.__proto__</code> 指向 A.prototype，接下来推导，A 和 B 要怎么才能实现这样的映射。</p> <div class="language- extra-class"><pre class="language-text"><code>b.__proto__.__proto__ = A.prototype
b.__proto__ = B.prototype
B.prototype.__proto__ = A.prototype
(new A()).__proto__ = A.prototype
B.prototype = new A()
</code></pre></div><h3 id="_5-2-盗用构造函数继承"><a href="#_5-2-盗用构造函数继承" class="header-anchor">#</a> 5.2，盗用构造函数继承</h3> <p>继承父类内部属性，可以在子类构造函数中调用父类构造函获取，并且使用 call/apply 修改父类函数的 this 指向子类，就可以将父类的属性传到自身了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token constant">A</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_5-3-组合式继承"><a href="#_5-3-组合式继承" class="header-anchor">#</a> 5.3，组合式继承</h3> <p>综合原型链继承和构造函数继承，我们得出最简单的组合继承为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a
<span class="token punctuation">}</span>
<span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">show</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token parameter">a <span class="token punctuation">,</span> b</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token constant">A</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b
<span class="token punctuation">}</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// {a: 1, b: 2, [[Prototype]]: { [[Prototype]]: { show } }</span>
</code></pre></div><h3 id="_5-4-其他继承"><a href="#_5-4-其他继承" class="header-anchor">#</a> 5.4，其他继承</h3> <p>本质也是修改原型链，只不过探讨出另一种修改原型链的方式。</p> <h4 id="_5-4-1-原型式继承"><a href="#_5-4-1-原型式继承" class="header-anchor">#</a> 5.4.1，原型式继承</h4> <p>调用函数，生成一个拥有特定原型属性的新对象，效果等同于 Object.create(obj)。</p> <p>本质是将一个空函数的 prototype 指向 obj，并构造该空函数实例，得到一个自身是空，但是原型属性指向 obj 的对象。</p> <p>不用使用 new 构造，new 在函数内部。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> 
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj
<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token comment">// { [[Prototype]]:obj }</span>
</code></pre></div><h4 id="_5-4-2-寄生式继承"><a href="#_5-4-2-寄生式继承" class="header-anchor">#</a> 5.4.2，寄生式继承</h4> <p>增强原型式继承所获得的对象，即让这个对象的自身也有点属性。</p> <p>获取原型式继承所获得的对象，为其添加其他属性，让对象拥有更多的功能。</p> <p>看起来没啥卵用，就是让实例对象多一点共性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 原型式继承</span>
<span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">Fun</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Real</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> clone <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取原型式继承后</span>
  clone<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 对该对象进行增强，即添加属性</span>
  <span class="token keyword">return</span> clone<span class="token punctuation">;</span> <span class="token comment">// 返回</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_5-4-3-寄生组合式继承"><a href="#_5-4-3-寄生组合式继承" class="header-anchor">#</a> 5.4.3，寄生组合式继承</h4> <p>组合式继承是通过<strong>调用父类构造函数</strong>修改原型链，而我们不提倡没有用的调用。</p> <p>故寄生式还是有点卵用的，它修改原型链的方式是可取的。</p> <p>使用寄生式修改组合式继承，得到寄生组合式，这也是最常使用的继承方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 原型式继承</span>
<span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">Fun</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 利用原型式继承父类原型</span>
<span class="token keyword">function</span> <span class="token function">inherit</span><span class="token punctuation">(</span><span class="token parameter">son，farther</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> prototype <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">(</span>farther<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// { [[Prototype]]:farther.prototype }</span>
    son<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype 
    prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Son 
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">Farther</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// 继承父类实例属性</span>
<span class="token punctuation">}</span>

<span class="token function">inherit</span><span class="token punctuation">(</span>Son，Farther<span class="token punctuation">)</span> <span class="token comment">// 继承父类原型属性</span>
</code></pre></div><h2 id="_6-类"><a href="#_6-类" class="header-anchor">#</a> 6，类</h2> <p>在 ES6 中，终于推出了类（Class）的概念。</p> <p>类比构造函数更加完整、简洁地实现了构造、继承，可将类看做是构造函数的语法糖。</p> <h3 id="_6-1-类与构造函数的异同"><a href="#_6-1-类与构造函数的异同" class="header-anchor">#</a> 6.1，类与构造函数的异同</h3> <p><strong>同</strong>：使用 typeof 检验皆返回 'function'、原型对象的 constructor 属性皆指回自身</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">newClass</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 类</span>
<span class="token keyword">function</span> <span class="token function">newFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 函数</span>

<span class="token keyword">typeof</span> newClass <span class="token comment">// 'function'</span>
<span class="token keyword">typeof</span> newFun <span class="token comment">// 'function'</span>

newClass<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">==</span> newClass <span class="token comment">// true</span>
newFun<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">==</span> newFun <span class="token comment">// true</span>
</code></pre></div><p><strong>异</strong>：构造函数可以当做普通函数直接调用，类只能使用 new 调用；</p> <p>声明式函数具有变量提升，类没有。</p> <p>构造函数原型对象的所有内容会被所有实例共享，但是类可以使用（static）定义静态方法，不被实例获取。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">newFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">newFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">newClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// error</span>
<span class="token keyword">new</span> <span class="token class-name">newClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_6-2-将构造函数改为类"><a href="#_6-2-将构造函数改为类" class="header-anchor">#</a> 6.2，将构造函数改为类</h3> <p>首先我们来了解一下类的结构,</p> <p>使用 class 关键字声明，本质为一个函数，但是结构像一个普通对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">newClass</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 可省但必须</span>
    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 可省且非必须</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>constructor</strong></p> <p>当使用构造类实例时，会自动调用类内部的 constructor 方法。</p> <p>若没有为类设置 constructor 方法时，浏览器会自动为类添加一个空的 constructor 方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">newClass</span><span class="token punctuation">{</span>
    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 等价于以下</span>
<span class="token keyword">class</span> <span class="token class-name">newClass</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>也是由 constructor 默认返回实例对象的，可以理解为 new 调用了 constructor，constructor 即是 ES5 的构造函数。</p> <p>故只要按照写构造函数一样写 constructor 就好，不需要新的 obj、使用 this、不需要返回值。</p> <p>优点：ES5 任凭什么阿猫阿狗函数都可以使用 new 调用，什么名字的函数都可以称之为构造函数，但是在类里，就固定叫 constructor。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">newFun</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b
<span class="token punctuation">}</span>
<span class="token comment">// 变成类的一part</span>
<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b
<span class="token punctuation">}</span>
</code></pre></div><p><strong>其他</strong><br>
除了 constructor 外，类中还可以设置其他命名的方法。</p> <p>不需要 function 关键字，方法间不使用逗号间隔，否则报错。</p> <p>此时类的所有方法（除了 static 标识的私有方法）都定义在类的 prototype 属性上面。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">newClass</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">newClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// { [[Prototype]] : { constructor, show, ...}}</span>
</code></pre></div><p>故可以将类拆为两部分，constructor 对应构造函数，其余方法对应构造函数的 prototype 对象。</p> <p>接下来看看构造函数如何转为类：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">newFun</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
newFun<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">show</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">'('</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token string">', '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">class</span> <span class="token class-name">newClass</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 1，对应构造函数</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 2，对应原型对象</span>
    <span class="token keyword">return</span> <span class="token string">'('</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token string">', '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_6-3-类的继承"><a href="#_6-3-类的继承" class="header-anchor">#</a> 6.3，类的继承</h3> <p>ES5 使用原型链继承，类使用 extends 继承，但本质都绕不开原型对象和原型属性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">newClass</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">newClass_E</span> <span class="token keyword">extends</span> <span class="token class-name">newClass</span> <span class="token punctuation">{</span>
  <span class="token comment">// 此处仍可以自定义方法，即自身的原型对象</span>
<span class="token punctuation">}</span>
</code></pre></div><p>newClass_E 继承了 newClass 的所有方法和属性，称为子类，newClass 称为父类。</p> <p>子类虽然为一个函数，但函数的本质是一个对象，拥有原型属性（<code>__proto__</code>），且原型属性指向了父类，使用 getPrototypeOf 检验：</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>newClass_E<span class="token punctuation">)</span> <span class="token operator">===</span> newClass <span class="token comment">// true</span>
newClass_E<span class="token punctuation">.</span>__proto__  <span class="token operator">===</span> newClass <span class="token comment">// true</span>
</code></pre></div><p>而子类作为函数，其原型对象为类内部定义的方法，又因原型对象拥有原型属性，原型属性指向父类的原型对象。</p> <div class="language-js extra-class"><pre class="language-js"><code>newClass_E<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> newClass<span class="token punctuation">.</span>prototype
</code></pre></div><p>接下来分析子类实例和父类的继承关系。</p> <div class="language-js extra-class"><pre class="language-js"><code>e_son<span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> newClass_E<span class="token punctuation">.</span>prototype
e_son<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> newClass_E<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> newClass<span class="token punctuation">.</span>prototype
</code></pre></div><p>故继承的原理是，子类原型对象的原型属性指向了父类的原型对象。</p> <div class="language-js extra-class"><pre class="language-js"><code>newClass<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>newClass_E<span class="token punctuation">)</span> <span class="token comment">// true</span>
e_son <span class="token keyword">instanceof</span> <span class="token class-name">newClass</span> <span class="token comment">// true</span>
</code></pre></div><h2 id="_7-附录"><a href="#_7-附录" class="header-anchor">#</a> 7，附录</h2> <p>下面是本章提到的，所有有关原型和原型链的相关方法与属性</p> <table><thead><tr><th>方法</th> <th>作用</th></tr></thead> <tbody><tr><td>Object.create(protoObj):obj</td> <td>创建一个新对象 obj ，将参数 protoObj 作为新对象所指向的原型对象</td></tr> <tr><td>Object.setPrototypeOf(obj，prototypeObj)</td> <td>传入两个对象，将参数 2 作为参数 1 的原型对象</td></tr> <tr><td>Object.getPrototypeOf(obj)</td> <td>获取参数 obj 所指向的原型对象</td></tr> <tr><td>Object.keys(obj)</td> <td>返回参数 obj 不包括可枚举属性的自身属性</td></tr> <tr><td>Object.getOwnPropertyNames(obj)</td> <td>返回参数 obj 非原型上的所有属性，<strong>包括不可枚举</strong>, 但不包括 Symbol 命名的属性</td></tr> <tr><td>Object.getOwnPropertySymbols(obj)</td> <td>返回参数 obj 非原型上的所有 Symbol 属性</td></tr> <tr><td>obj.hasOwnProperty(attribute)</td> <td>传入一个字符串属性，返回一个 Boolean 值，判断是<strong>自身属性</strong>还是原型对象上的属性</td></tr> <tr><td>Object.prototype.isPrototypeOf(obj)</td> <td>传一个实例对象，判断该实例是不是在原型链中</td></tr> <tr><td>Object.prototype.constructor</td> <td>指回构造函数</td></tr> <tr><td>obj instanceof Object</td> <td>左边是实例，右边是构造函数，判断实例的原型链中是否有该构造函数</td></tr></tbody></table> <h3 id="_7-1-原型链考题"><a href="#_7-1-原型链考题" class="header-anchor">#</a> 7.1 原型链考题</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proro__ <span class="token operator">===</span> <span class="token keyword">null</span>
Object<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype
Function<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> Object<span class="token punctuation">.</span>__proto__


<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> <span class="token class-name">A</span><span class="token punctuation">.</span>prototype
<span class="token constant">B</span><span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> <span class="token constant">A</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.6530ad20.js" defer></script><script src="/assets/js/2.2defd20b.js" defer></script><script src="/assets/js/17.2323a2f9.js" defer></script>
  </body>
</html>
